#!/usr/bin/python3
# A program to control a Delcom Engineering USB Numeric Display (USB ID 0fc5:1227)
# Note that this is the old display type.
# http://www.delcomproducts.com/products_USBNDisplay.asp
# Copyright 2010, 2014, 2017, 2025 Stuart Pook http://www.pook.it/
# https://github.com/stuart12/delcom-clock

# Tested on Python and Linux 4.19 and 5.2
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/usb/misc_usbsevseg.txt
# https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/usb/misc/usbsevseg.c

import os
import os.path
import sys
import argparse
import time
import stat
import json
import logging
import pwd
import re
import syslog
import signal
import functools
import errno
import asyncio
import paho.mqtt.client
import socket
import aiomqtt # https://github.com/empicano/aiomqtt

DIGITS = 8 # digits in the clock (compiled into kernel)

def excepthook(*args):
  logging.getLogger().error('Uncaught exception:', exc_info=args)
sys.excepthook = excepthook

def myname():
    return sys.argv[0]

def info(mess):
    logging.info(mess)

def message(mess):
    logging.debug(mess)

def error(do_syslog, mess):
    logging.error(mess)
    print(myname(), mess, file=sys.stderr)
    if do_syslog:
        syslog.syslog(syslog.LOG_ERR, mess)

def set_parameter(device, parameter, value):
    message("set_parameter(%s, %s, %s)" % (device, parameter, value))
    name = os.path.join(device, parameter)
    message("setting " + name + " to " + value)
    f = open(name, "w")
    f.write(value + "\n")
    f.close()
    message("set " + name + " to " + value)

def signal_handler(short_device, do_syslog, signal, frame):
    mess = "%s: exiting on signal %d" % (short_device, signal)
    if do_syslog:
        syslog.syslog(syslog.LOG_INFO, mess)
    else:
        message(mess)
    sys.exit(1)


def get_options():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="show the time on a Delcom Engineering USB Numeric Display")
    parser.set_defaults(loglevel='warn')
    parser.add_argument("-v", "--verbose", dest='loglevel', action="store_const", const='debug', help="debug loglevel")
    parser.add_argument("-l", "--loglevel", metavar="LEVEL", help="set logging level")
    parser.add_argument("--usbsevseg", default="/sys/bus/usb/drivers/usbsevseg", metavar="PATH", help="sys path to displays")
    parser.add_argument('-s', "--syslog", action="store_true", help="send errors to syslog")
    parser.add_argument("--reconnect", type=float, metavar="SECONDS", default=60, help="delay reconnection attempts")
    parser.add_argument("--update", type=int, metavar="SECONDS", default=1, help="delay between updates")
    parser.add_argument("--format", default="%(tm_hour)02d.%(tm_min)02d.%(tm_sec)02d", help="strftime pattern for display")
    parser.add_argument("--number", metavar="TOPIC:KEY", action='append', help="mqtt topic and key")
    parser.add_argument('--off', action="store_true", help="start off")
    parser.add_argument('-n', '--only_format', action="store_true", help="just format the output string")
    parser.add_argument("--mqttbroker", default="localhost", help="mqtt broker")
    parser.add_argument("--id", default="delcom-clock", help="tag for mqtt broker and topics")
    parser.add_argument("--mqttuser", help="mqtt password")
    parser.add_argument("--mqttpassword", help="mqtt password")
    parser.add_argument("--mqttpasswordfile","--mqttpasswdfile", metavar="FILENAME", help="file containing mqtt password")
    parser.add_argument('display', nargs=1, help='display name')
    options = parser.parse_args()
    return options


def format_output(localtime, pformat:str, numbers: dict):
    args = numbers | {
        'tm_year': localtime.tm_year,
        'tm_mon': localtime.tm_mon,
        'tm_mday': localtime.tm_mday,
        'tm_hour': localtime.tm_hour,
        'tm_min': localtime.tm_min,
        'tm_sec': localtime.tm_sec,
        'tm_tenthsec': localtime.tm_sec // 10,
        'tm_wday': localtime.tm_wday,
        'tm_yday': localtime.tm_yday,
        'tm_isdst': localtime.tm_isdst,
         }
    r = pformat % args
    logging.debug("format %s.format(%s) -> %s", pformat, args, r)
    return r

def split_text(now, pformat, numbers: dict):
    text = format_output(now, pformat, numbers)
    digits = ''
    decimals = ''
    pending = ''
    for c in text:
        if c == '.':
            assert pending != ''
            pending = '1'
        else:
            decimals += pending
            digits += c
            pending = '0'
    decimals += pending
    assert len(decimals) == len(digits), "len(%s) != len(%s)" % (decimals, digits)
    return digits[-DIGITS:], decimals[-DIGITS:], text


def get_password(password, password_file):
    if password:
        return password
    with open(password_file) as f:
        logging.debug("reading password from %s", password_file)
        return f.readline().strip('\n')


class DelcomClock:
    def __init__(self, options, numbers: list, name:str):
        self.options = options
        self._numbers = { number: 0.0 for number in numbers }
        if options.only_format:
            text, decimals, full = split_text(time.localtime(time.time()), options.format, self._numbers)
            print(text, decimals, full)
            exit(0)

        device = os.path.join(options.usbsevseg, name)
        short_device = os.path.basename(device)

        logging.debug("device " + short_device)

        info("starting " + device)

        if options.syslog:
            syslog.openlog("delcom-clock",  0,  syslog.LOG_DAEMON)
            syslog.syslog(syslog.LOG_INFO, "%s: starting %s (%s)" % (short_device, device, options.display[0]))

        try:
            level = os.path.join(device, "../power/level")
            message("opening " + level)
            power = open(level)
            message("opened " + level)
            power_required = "auto\n"
            old_power = power.readline()
            power.close()

            if old_power != power_required:
                message("power was " + old_power)
                power = open(level, "w")
                message("opened " + level)
                power.write(power_required)
                power.close()
                magic_delay = 5.0
                message("sleeping " + str(magic_delay))
                time.sleep(magic_delay)
                message("slept " + str(magic_delay))

            set_parameter(device, "powered", "1")
            set_parameter(device, "mode_msb", "8")
            set_parameter(device, "mode_lsb", "255")
            set_parameter(device, "textmode", "ascii")

            self.text_filename = os.path.join(device, "text")
            self.text = open(self.text_filename, "w", buffering=1)
            self.decimals = open(os.path.join(device, "decimals"), "w", buffering=1)
        except Exception as e:
            syslog.syslog(syslog.LOG_ERR,  short_device + ": initialisation error: " + str(e))
            raise

        self.command_gap = 25 / 1000.0
        time.sleep(self.command_gap)

        try:
            if options.off:
                print("1" + "0" * (DIGITS - 1), file=self.decimals)
                time.sleep(0.75 + self.command_gap)
                print("0" * DIGITS, file=decimals)
            else:
                print("8" * DIGITS, file=self.text)
                time.sleep(self.command_gap)
                print("1" * DIGITS, file=self.decimals)
                time.sleep(0.75 + self.command_gap)
                print("1" * DIGITS, file=self.decimals)
        except Exception as e:
            syslog.syslog(syslog.LOG_ERR,  "error on " + device + ": " + str(e))
            raise
            
        self._last_run = time.time()

        #set_parameter(device, "decimals", decimals)
        logging.info("starting %s every %f", options.format, options.update)
        if options.syslog:
            syslog.syslog(syslog.LOG_INFO, "%s: updating %s every %d seconds controlled by %s" % (short_device, options.format, options.update, options.control))
        self.on = not options.off
        self.digits = self.dots = "x"

    def run(self):
        now = time.time()
        localtime = time.localtime(now)
        logging.debug("run at %.4f %s", now, localtime)
        
        need_to_wait = self._last_run + self.command_gap - now
        if need_to_wait > 0:
            logging.info("skip as last run too recent: %f = %f + %f - %f", need_to_wait, self._last_run, self.command_gap, now)
            return need_to_wait

        if self.on:
            digits, dots, _ = split_text(localtime, self.options.format, self._numbers)
        else:
            digits = dots = ""
        try:
            if self.digits != digits:
                print(digits, file=self.text)
                self._last_run = now
                self.digits = digits
                if self.dots != dots:
                    logging.debug("return minimum gap as dots %s != %s", dots, self.dots)
                    return self.command_gap
            elif self.dots != dots:
                print(dots, file=self.decimals)
                self._last_run = now
                self.dots = dots
        except OSError as ex:
            error(options.syslog, "failed to write: %s: %s" % (self.text_filename, ex))
            if ex.errno == errno.ENODEV:
                error(options.syslog, "exit(0) after ENODEV")
                sys.exit(0)
            raise
        
        if not self.on:
            return max(self.options.update, 60 * 60 * 24)

        now = time.time()

        # this line is the hardest to get right
        # delay = self.options.update - now % 60 % self.options.update
        delay = (int(now) // self.options.update + 1) * self.options.update - now
        if delay < self.command_gap:
            logging.info("delay too small %f = (%d // %d + 1) * %d - %0.3f < %0.3f", delay, int(now), self.options.update, self.options.update, now, self.command_gap)
            delay = self.command_gap
        message('[' + digits + "] delay=" + str(delay) + " " + str(now) + " " + str(localtime.tm_sec) + ' ' + str(now % 60))
        return delay
        
    def number(self, key: str, value: float):
        self._numbers[key] = value
        logging.info("message %s/%f: numbers %s", key, value, self._numbers)
        
    def control(self, state):
        if state == "on":
            self.on = True
        elif state == "off":
            self.on = False
        elif state == "toggle":
            self.on = not self.on
        else:
            logging.warning("unexpected state %s when on=%s", state, self.on)
        return self.get_status()
        
    def get_status(self):
        return "on" if self.on else "off"


async def run_clock(incoming: asyncio.Queue, outgoing: asyncio.Queue, clock: DelcomClock, numbers: dict, command_topic: str):
    outgoing.put_nowait(clock.get_status())
    while True:
        delay = clock.run()
        try: # https://superfastpython.com/asyncio-queue/#Example_of_Asyncio_Queue_With_Timeout
            get_await = incoming.get()
            logging.debug("wait_for %0.3f", delay)
            message = await asyncio.wait_for(get_await, delay)
            logging.debug("after wait_for %0.3f: %s", delay, message)
            if message[0] == command_topic:
                new_state = message[1].decode()
                state = clock.control(new_state.lower())
                outgoing.put_nowait(state.upper())
                logging.info("after state change to %s state=%s outgoing=%d", new_state, state, outgoing.qsize())
            else:
                key = numbers.get(message[0], None)
                if key:
                    logging.debug("wait %0.3f message %s", delay, message)
                    clock.number(key=key, value=float(message[1]))
                else:
                    logging.warning("after %fs unexpected message %s", delay, message)
        except asyncio.TimeoutError:
            logging.debug("wait %0.2f timeout", delay)


async def listener(client: aiomqtt.Client, messages: asyncio.Queue):
    async for message in client.messages:
        logging.debug("got a message from client.messages: %s %s", message.topic, message.payload)
        messages.put_nowait([str(message.topic), message.payload])
    logging.error("end of listener")


async def publisher(client: aiomqtt.Client, topic:str, outgoing: asyncio.Queue):
    while True:
        status = await outgoing.get()
        logging.debug("retrieved a status to send %s, %d remaining", status, outgoing.qsize())
        await client.publish(topic, status)
        outgoing.task_done()
    logging.error("end of publisher")


def make_unique_id(hostname: str, device: str) -> str:
    new_device = re.sub(r'[^a-z0-9]', 'z', device.lower().translate(str.maketrans('-:.', 'dcf')))
    new_hostname = re.sub(r'[^a-z0-9]', 'y', hostname.lower())
    return f"{new_hostname}_{new_device}"


class MakeTopic:
    def __init__(self, identifier, device, hostname):
        self._device = device
        self._clean_device = re.sub(r'[^a-z0-9]', 'z', self._device.lower().translate(str.maketrans('-:.', 'dcf')))
        self._identifier = identifier
        self._hostname = hostname

    def identifier(self):
        return self._identifier

    def hostname(self):
        return self._hostname

    def device(self):
        return self._device

    def clean_device(self):
        return self._clean_device

    def unique_id(self):
        new_hostname = re.sub(r'[^a-z0-9]', 'y', self._hostname.lower())
        return f"{new_hostname}_{self._clean_device}"

    def _make(self, topic):
        return f"{self._identifier}/{topic}/{self._hostname}/{self._device}"

    def availability(self):
        return self._make('availability')

    def command(self):
        return self._make('command')

    def state(self):
        return self._make('state')


async def send_mqtt_configuration(client: aiomqtt.Client, make_topics: MakeTopic) -> None:
    # https://stevessmarthomeguide.com/adding-an-mqtt-device-to-home-assistant/
    # https://www.home-assistant.io/integrations/mqtt/#mqtt-discovery
    unique_id = make_topics.unique_id()
    command_topic = make_topics.command()
    discovery_topic = f"homeassistant/light/{unique_id}/config"
    logging.info("publishing homeassistance discovery on %s for %s", discovery_topic, command_topic)
    payload = {
        "device": {
            "identifiers": [f"{make_topics.hostname()}-{make_topics.device()}"],
            "name": f"Delcom {make_topics.hostname()} {make_topics.device()}",
            "manufacturer": "Delcom Engineering",
            "model": "USB 8 Digit Numeric Display",
        },
        "origin": {
            "name": make_topics.identifier(),
            "sw_version": "1.0",
            "url": "https://github.com/stuart12/delcom-clock",
        },
        "unique_id": unique_id,
        "object_id": f"Delcom {make_topics.hostname()} {make_topics.clean_device()}",
        "availability_topic": make_topics.availability(),
        "command_topic": command_topic,
        "state_topic": make_topics.state(),
        "qos": 2,
    }
    await client.publish(discovery_topic, json.dumps(payload), retain=True)
    await client.publish(make_topics.availability(), "online")


async def mqtt(topics:list, incoming: asyncio.Queue, outgoing: asyncio.Queue,
        broker: str, user:str, password:str, clientid:str,
        make_topics: MakeTopic,
        reconnect_delay: float,
    ):
    logging.info("aiomqtt.Client(hostname=%s, username=%s, password=password, identifier=%s)", broker, user, clientid)
    will = aiomqtt.Will(topic=make_topics.availability(), payload="offline", qos=2, retain=False) # https://github.com/empicano/aiomqtt/issues/28
    client = aiomqtt.Client(hostname=broker, username=user, password=password, identifier=clientid, will=will)
    while True:
        try: # https://aiomqtt.bo3hm.com/subscribing-to-a-topic.html
            async with client:
                await client.subscribe(make_topics.command())
                for topic in topics:
                    await client.subscribe(topic)
                await send_mqtt_configuration(client, make_topics)
                async with asyncio.TaskGroup() as tg:
                    tg.create_task(listener(client, incoming))
                    tg.create_task(publisher(client, make_topics.state(), outgoing))
            logging.error("after async")
        except aiomqtt.MqttError:
            logging.warning("Connection lost to %s; Reconnecting in %f seconds ...", broker, reconnect_delay)
            await asyncio.sleep(reconnect_delay)


def make_mqtt_clientid(hostname: str, device: str) -> str:
    # consists of alphanumeric characters only, with a length restriction often between 1 and 23 characters
    new_device = re.sub(r'[^a-z0-9]', 'z', device.lower().translate(str.maketrans('-:.', 'dcf')))
    new_hostname = re.sub(r'[^a-z0-9]', 'y', hostname.lower())
    suffix = f"x{new_device}"
    return f"delcom{new_hostname}"[0:23 - len(suffix)] + suffix


async def main():
    options = get_options()
    numeric_level = getattr(logging, options.loglevel.upper(), None)
    if not isinstance(numeric_level, int):
        sys.exit('Invalid log level: %s' % options.loglevel)
    logging.basicConfig(level=numeric_level)
    
    numbers = {k.split(':')[0] : k.split(':')[1] for k in options.number}
    device = options.display[0]
    clock = DelcomClock(options=options, numbers=numbers.values(), name=device)
    hostname = socket.gethostname()
    make_topics = MakeTopic(options.id, device=device, hostname=hostname)

    clientid = make_mqtt_clientid(hostname=hostname, device=device)
    password = get_password(options.mqttpassword, options.mqttpasswordfile)

    incoming = asyncio.Queue()
    outgoing = asyncio.Queue()
    
    async with asyncio.TaskGroup() as tg: # https://aiomqtt.bo3hm.com/subscribing-to-a-topic.html
        tg.create_task(mqtt(topics=numbers.keys(),
            incoming=incoming,
            outgoing=outgoing,
            broker=options.mqttbroker, user=options.mqttuser, password=password, clientid=clientid,
            make_topics=make_topics,
            reconnect_delay=options.reconnect,
        ))
        tg.create_task(run_clock(incoming=incoming, outgoing=outgoing, clock=clock, numbers=numbers, command_topic=make_topics.command()))


if __name__ == "__main__":
    asyncio.run(main())
