#!/usr/bin/python3
# A program to control a Delcom Engineering USB Numeric Display (USB ID 0fc5:1227)
# Note that this is the old display type.
# http://www.delcomproducts.com/products_USBNDisplay.asp
# Copyright 2010, 2014, 2017 Stuart Pook http://www.pook.it/
# https://github.com/stuart12/delcom-clock

# Tested on Python and Linux 2.6.34, 2.6.37, 3.14, 4.9
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import sys
import argparse
import time
import select
import stat
import math
import pwd
import syslog
import signal
import functools

def myname():
    return sys.argv[0]

def message(debug, mess):
    if debug != None:
        debug.write(mess + "\n")
        debug.flush()

def error(do_syslog, debug, mess):
    message(debug, mess)
    print(myname(), mess, file=sys.stderr)
    if do_syslog:
        syslog.syslog(syslog.LOG_ERR, mess)

def set_parameter(device, parameter, value, debug):
    message(debug, "set_parameter(%s, %s, %s)" % (device, parameter, value))
    name = os.path.join(device, parameter)
    message(debug, "setting " + name + " to " + value)
    f = open(name, "w")
    f.write(value + "\n")
    f.close()
    message(debug, "set " + name + " to " + value)

def signal_handler(short_device, do_syslog, debug, signal, frame):
    mess = "%s: exiting on signal %d" % (short_device, signal)
    if do_syslog:
        syslog.syslog(syslog.LOG_INFO, mess)
    else:
        message(debug, mess)
    sys.exit(1)

def get_options():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="show the time on a Delcom Engineering USB Numeric Display")
    parser.add_argument("--usbsevseg", default="/sys/bus/usb/drivers/usbsevseg", metavar="PATH", help="sys path to displays")
    parser.add_argument("--chown", default=None, metavar="USER", help="owner of control pipe")
    parser.add_argument("--control", default=None, metavar="PATH", help="named pipe for control")
    parser.add_argument('-s', "--syslog", action="store_true", help="send errors to syslog")
    parser.add_argument('-v', "--verbose", action="store_true", help="verbose")
    parser.add_argument("--decimals", default="10100", metavar="PATTERN", help="position of dots")
    parser.add_argument("--debug", default=None, metavar="PATH", help="file for debug messages")
    parser.add_argument("--format", default="%H%M%S", metavar="PATTERN", help="strftime pattern for display")
    parser.add_argument("--update", type=int, metavar="SECONDS", default=1, help="delay between updates")
    parser.add_argument("--fork", action="store_true", help="fork")
    parser.add_argument('--off', action="store_true", help="start off")
    parser.add_argument('display', nargs=1, help='display name')
    options = parser.parse_args()
    return options

def run(options):
    do_syslog = options.syslog or options.fork

    device = os.path.join(options.usbsevseg, options.display[0])
    short_device = os.path.basename(device)

    if options.debug:
        debug = open(options.debug, "w")
        sys.stderr = debug
        sys.stdout = debug
        debug.write("device " + short_device + "\n")
    elif options.verbose:
        debug = sys.stderr
    else:
        debug = None

    message(debug, "starting " + device)

    if do_syslog:
        syslog.openlog("delcom-clock",  0,  syslog.LOG_DAEMON)
        syslog.syslog(syslog.LOG_INFO, "%s: starting %s (%s)" % (short_device, device, options.display[0]))

    for s in [ signal.SIGINT, signal.SIGTERM, signal.SIGHUP ]:
        signal.signal(s, functools.partial(signal_handler, short_device, do_syslog, debug))

    poller = select.poll()

    try:
        level = os.path.join(device, "../power/level")
        message(debug, "opening " + level)
        power = open(level)
        message(debug, "opened " + level)
        power_required = "auto\n"
        old_power = power.readline()
        power.close()
        if options.fork and os.fork() != 0:
            sys.exit(0)
            
        if old_power != power_required:
            message(debug, "power was " + old_power)
            power = open(level, "w")
            message(debug, "opened " + level)
            power.write(power_required)
            power.close()
            magic_delay = 5.0
            message(debug, "sleeping " + str(magic_delay))
            time.sleep(magic_delay)
            message(debug, "slept " + str(magic_delay))
            
        set_parameter(device, "powered", "1", debug)
        set_parameter(device, "mode_msb", "8", debug)
        set_parameter(device, "mode_lsb", "255", debug)
        set_parameter(device, "textmode", "ascii", debug)

        text_filename = os.path.join(device, "text")
        text = open(text_filename, "w", buffering=1)
        decimals = open(os.path.join(device, "decimals"), "w", buffering=1)
    except Exception as e:
        syslog.syslog(syslog.LOG_ERR,  short_device + ": initialisation error: " + str(e))
        raise

    command_gap = 25
    time.sleep(command_gap / 1000.0)

    length = 8
    try:
        print("01" + "0" * (length - 2), file=decimals)
        time.sleep(0.5 +command_gap / 1000.0)
    except IOError as e:
        length = 6
        message(debug, "set length to %d" % length)

    time.sleep(command_gap / 1000.0)

    try:
        if options.off:
            print("1" + "0" * (length - 1), file=decimals)
            time.sleep(0.75 + command_gap / 1000.0)
            print("0" * length, file=decimals)
        else:
            print("8" * length, file=text)
            time.sleep(command_gap / 1000.0 )
            print("1" * length, file=decimals)
            time.sleep(0.75 +command_gap / 1000.0)
            print(options.decimals[-length:], file=decimals)
    except Exception as e:
        syslog.syslog(syslog.LOG_ERR,  "error on " + device + ": " + str(e))
        raise

    #set_parameter(device, "decimals", decimals, debug)
    time.sleep(command_gap / 1000.0)

    try:
        if options.control != None:
            if not os.path.exists(options.control):
                os.mkfifo(options.control, 0o600)
                if options.chown != None:
                    uids = pwd.getpwnam(options.chown)
                    os.chown(options.control, uids.pw_uid, uids.pw_gid)
                    message(debug, "chown " + options.control + " to " + str(uids.pw_uid) + ":" + str(uids.pw_gid))
            message(debug, "opening for read " + options.control)
            control_fd = os.open(options.control, os.O_RDONLY | os.O_NONBLOCK)
            if not stat.S_ISFIFO(os.fstat(control_fd)[stat.ST_MODE]):
                sys.exit(options.control + " is not a pipe");
            poller.register(control_fd)
            keep_it_open_so_do_not_block = os.open(options.control, os.O_WRONLY)
            message(debug, "opened " + options.control)
    except Exception as e:
        syslog.syslog(syslog.LOG_ERR, "error setting up control " + options.control + ": " + str(e))
        raise

    message(debug, "starting " + options.format + " " + str(options.update))
    if do_syslog:
        syslog.syslog(syslog.LOG_INFO, "%s: updating %s every %d seconds controlled by %s" % (short_device, options.format, options.update, options.control))
    on = not options.off
    while True:
        now = time.time()
        localtime = time.localtime(now)
        out = time.strftime(options.format, localtime)[-length:]
        try:
            print(out if on else "", file=text)
        except OSError as ex:
            error(do_syslog, debug, "failed to write: %s: %s" % (text_filename, ex))
            raise

        # this line is the hardest to get right
        delay = options.update - now % 60 % options.update
        rdelay =  int(math.ceil(delay * 1000))
        if rdelay < command_gap + 1:
            message(debug, "rdelay too small " + str(rdelay))
            rdelay = command_gap
        message(debug, '[' + out + "] delay=" + str(delay) + " " + str(now) + " " + str(localtime.tm_sec) + ' ' + str(now % 60) + " " + str(rdelay))
        read = poller.poll(rdelay)
        if read != []:
            message(debug, "something to read")
            s = os.read(read[0][0],  100)
            message(debug, "read " + str(s))
            old_on = on
            for c in s:
                if c == ord("0"):
                    on = False
                elif c == ord("1"):
                    on = True
                elif c == ord('~'):
                    on = not on
                elif c == ord('!'):
                    messages = ["", out]
                    for m in [not on, on]:
                        time.sleep(4 * command_gap / 1000.0)
                        print(messages[int(m)], file=text)
                elif c == ord('\n'):
                    pass
                else:
                    message(debug, "unexpected read " + str(c))
            time.sleep(command_gap / 1000.0)
            if old_on != on:
                if on:
                    print(options.decimals[-length:], file=decimals)
                else:
                    print(file=decimals)
                message(debug, "powered " + str(on))
                time.sleep(command_gap / 1000.0)

def main():
    run(get_options())

if __name__ == "__main__":
    main()
