#!/usr/bin/python
# A program to control a Delcom Engineering USB Numeric Display (USB ID 0fc5:1227)
# Note that this is the old display type.
# http://www.delcomproducts.com/products_USBNDisplay.asp
# 17 May 2014, Copyright 2010, 2014 Stuart Pook http://www.pook.it/
# https://github.com/stuart12/delcom-clock

# Tested on Python 2.6.6 and Linux 2.6.34, 2.6.37, 3.14
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import sys
import getopt
import time
import select
import stat
import math
import pwd
import syslog
import signal

def message(debug, mess):
	if debug != None:
		debug.write(mess + "\n")
		debug.flush()

def set_parameter(device, file, value, debug):
	message(debug, "set_parameter(%s, %s, %s)" % (device, file, value))
	name = os.path.join(device, file)
	message(debug, "setting " + name + " to " + value)
	f = open(name, "w")
	f.write(value + "\n")
	f.close()
	message(debug, "set " + name + " to " + value)
def usage():
	sys.exit("usage: " + myname + " " + str(options))

myname = os.path.basename(sys.argv[0])
verbose = False
seconds = False
fork = False
options = [ "usbsevseg=", "chown=", "control=", "syslog", "decimals=", "debug=", "format=", "update=", "fork", "delay=", "verbose", "noverbose", ]
dots = "10100"
format = "%H%M%S"
update = 1
debug = None
control = None
chown = None
do_syslog = False
usbsevseg = "/sys/bus/usb/drivers/usbsevseg"
try:
	opts, args = getopt.getopt(sys.argv[1:], "v", options)
except getopt.GetoptError:
	print "help"
	usage()
for o, a in opts:
	if o in ("--fork"):
		fork = True
		do_syslog = True
	elif o in ("--chown"):
		chown = a
	elif o in ("--decimals"):
		dots = a
	elif o in ("--format"):
		format = a
	elif o in ("--usbsevseg"):
		usbsevseg = a
	elif o in ("--control"):
		control = a
	elif o in ("--syslog"):
		do_syslog = True
	elif o in ("--debug"):
		debug = open(a, "w")
	elif o in ("--update"):
		update = int(a)
	elif o in ("-v", "--verbose"):
		debug = open("/dev/stdout", "w")
	elif o in ("--noverbose"):
		debug = None
	else:
		print "bad option", o
		usage()

if not args:
	usage()

device = os.path.join(usbsevseg, args[0])
short_device = os.path.basename(device)

if do_syslog:
	syslog.openlog("delcom-clock",  0,  syslog.LOG_DAEMON)
	syslog.syslog(syslog.LOG_INFO, "%s: starting %s (%s)" % (short_device, device, args[0]))
if debug:
	sys.stderr = debug
	sys.stdout = debug
	debug.write("device " + short_device + "\n")

def signal_handler(signal, frame):
	syslog.syslog(syslog.LOG_INFO, "%s: exiting on signal %d" % (short_device, signal))
	sys.exit(1)
for s in [ signal.SIGINT, signal.SIGTERM, signal.SIGHUP ]:
	signal.signal(s, signal_handler)

poller = select.poll()

try:
	level = os.path.join(device, "../power/level")
	message(debug, "opening " + level)
	power = open(level)
	message(debug, "opened " + level)
	power_required = "auto\n"
	old_power = power.readline()
	power.close()
	if fork and os.fork() != 0:
		sys.exit(0)
		
	if old_power != power_required:
		message(debug, "power was " + old_power)
		power = open(level, "w")
		message(debug, "opened " + level)
		power.write(power_required)
		power.close()
		magic_delay = 5.0
		message(debug, "sleeping " + str(magic_delay))
		time.sleep(magic_delay)
		message(debug, "slept " + str(magic_delay))
		
	set_parameter(device, "powered", "1", debug)
	set_parameter(device, "mode_msb", "8", debug)
	set_parameter(device, "mode_lsb", "255", debug)
	set_parameter(device, "textmode", "ascii", debug)

	text = open(os.path.join(device, "text"), "w", buffering=0)
	decimals = open(os.path.join(device, "decimals"), "w", buffering=0)
except Exception as e:
	syslog.syslog(syslog.LOG_ERR,  short_device + ": initialisation error: " + str(e))
	raise

command_gap = 25
time.sleep(command_gap / 1000.0)

length = 8
try:
	text.write("6" * length + "\n")
	time.sleep(0.5 +command_gap / 1000.0)
except IOError as e:
	length = 6
	message(debug, "set length to %d" % length)

time.sleep(command_gap / 1000.0)

try:
	text.write("8" * length + "\n")
	time.sleep(command_gap / 1000.0 )
	decimals.write("1" * length + "\n")
	time.sleep(0.75 +command_gap / 1000.0)
	decimals.write(dots[-length:] + "\n")
except Exception as e:
	syslog.syslog(syslog.LOG_ERR,  "error on " + device + ": " + str(e))
	raise

#set_parameter(device, "decimals", decimals, debug)
time.sleep(command_gap / 1000.0)

try:
	if control != None:
		if not os.path.exists(control):
			os.mkfifo(control, 0600)
			if chown != None:
				uids = pwd.getpwnam(chown)
				os.chown(control, uids.pw_uid, uids.pw_gid)
				message(debug, "chown " + control + " to " + str(uids.pw_uid) + ":" + str(uids.pw_gid))
		message(debug, "opening for read " + control)
		control_fd = os.open(control, os.O_RDONLY | os.O_NONBLOCK)
		if not stat.S_ISFIFO(os.fstat(control_fd)[stat.ST_MODE]):
			sys.exit(control + " is not a pipe");
		poller.register(control_fd)
		keep_it_open_so_do_not_block = os.open(control, os.O_WRONLY)
		message(debug, "opened " + control)
except Exception as e:
	syslog.syslog(syslog.LOG_ERR, "error setting up control " + control + ": " + str(e))
	raise

message(debug, "starting " + format + " " + str(update))
if do_syslog:
	syslog.syslog(syslog.LOG_INFO, "%s: updating %s every %d seconds controlled by %s" % (short_device, format, update, control))
on = True
while True:
	now = time.time()
	if on:
		localtime = time.localtime(now)
		out = time.strftime(format, localtime)
	else:
		out = ""
	text.write(out[-length:] + '\n')
	# this line is the hardest to get right
	delay = update - now % 60 % update
	rdelay =  int(math.ceil(delay * 1000))
	if rdelay < command_gap + 1:
		message(debug, "rdelay too small " + str(rdelay))
		rdelay = command_gap
	message(debug, '[' + out + "] delay=" + str(delay) + " " + str(now) + " " + str(localtime.tm_sec) + ' ' + str(now % 60) + " " + str(rdelay))
	read = poller.poll(rdelay)
	if read != []:
		message(debug, "something to read")
		s = os.read(read[0][0],  100)
		message(debug, "read " + s)
		old_on = on
		for c in s:
			if c == "0":
				on = False
			elif c == "1":
				on = True
			elif c == '~':
				on = not on
		time.sleep(command_gap / 1000.0)
		if old_on != on:
			if on:
				decimals.write(dots[-length:] + "\n")
			else:
				decimals.write("\n")
			message(debug, "powered " + str(on))
			time.sleep(command_gap / 1000.0)
